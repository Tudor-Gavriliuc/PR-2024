#  Create your custom serialization technique that
#  can serialize and deserialize data.[4]

import socket
import ssl
from bs4 import BeautifulSoup
from functools import reduce
from datetime import datetime, timezone

# Target server and port
host = '999.md'
port = 443  # HTTPS uses port 443

# HTTP request template (GET request for a specific page)
request = f"GET /ro/list/computers-and-office-equipment/tablet HTTP/1.1\r\nHost: {host}\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/129.0.0.0 Safari/537.36\r\nConnection: close\r\n\r\n"

# Create an SSL context
context = ssl.create_default_context()

# Create a socket and connect to the server
with socket.create_connection((host, port)) as sock:
    with context.wrap_socket(sock, server_hostname=host) as ssl_sock:
        ssl_sock.sendall(request.encode())
        response_data = b""
        while True:
            chunk = ssl_sock.recv(4096)
            if not chunk:
                break
            response_data += chunk

# Decode the response to string
response_text = response_data.decode()

# Find the start of the HTTP body (after headers)
header_end_idx = response_text.find("\r\n\r\n")
if header_end_idx != -1:
    html_body = response_text[header_end_idx + 4:]

# Pass the HTML body to BeautifulSoup for scraping
soup = BeautifulSoup(html_body, 'html.parser')

def scrape_product_details(product_link):
    with socket.create_connection((host, port)) as sock:
        with context.wrap_socket(sock, server_hostname=host) as ssl_sock:
            request = f"GET {product_link} HTTP/1.1\r\nHost: {host}\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/129.0.0.0 Safari/537.36\r\nConnection: close\r\n\r\n"
            ssl_sock.sendall(request.encode())
            
            product_response_data = b""
            while True:
                chunk = ssl_sock.recv(4096)
                if not chunk:
                    break
                product_response_data += chunk

    product_response_text = product_response_data.decode()
    header_end_idx = product_response_text.find("\r\n\r\n")
    if header_end_idx != -1:
        product_html_body = product_response_text[header_end_idx + 4:]
    else:
        return "Descriere indisponibilă"

    product_soup = BeautifulSoup(product_html_body, 'html.parser')
    description_tag = product_soup.find('div', class_='adPage__content__description grid_18', itemprop='description')

    return description_tag.get_text(strip=True) if description_tag else "Descriere indisponibilă"

def convert_to_eur(price_mdl):
    conversion_rate = 20
    return round(price_mdl / conversion_rate, 2)

def convert_to_mdl(price_eur):
    conversion_rate = 20
    return round(price_eur * conversion_rate, 2)

products = soup.find_all('li', class_='ads-list-photo-item')

product_data = []
for index, product in enumerate(products):
    if index >= 20:
        break

    name_tag = product.find('div', class_='ads-list-photo-item-title')
    name = name_tag.find('a').get_text(strip=True) if name_tag else "Nume indisponibil"

    price_tag = product.find('div', class_='ads-list-photo-item-price')
    price_text = price_tag.get_text(strip=True) if price_tag else "0"

    price_mdl = 0
    price_eur = 0

    if 'lei' in price_text:
        price_text = price_text.replace('lei', '').replace(' ', '')
        try:
            price_mdl = float(price_text)
            price_eur = convert_to_eur(price_mdl)
        except ValueError:
            continue
    elif '€' in price_text:
        price_text = price_text.replace('€', '').replace(' ', '')
        try:
            price_eur = float(price_text)
            price_mdl = convert_to_mdl(price_eur)
        except ValueError:
            continue

    link = name_tag.find('a')['href'] if name_tag and name_tag.find('a') else None
    if link:
        link = f"https://999.md{link}" if link.startswith("/") else link
    else:
        continue

    product_data.append({
        'name': name,
        'link': link,
        'price_mdl': price_mdl,
        'price_eur': price_eur,
        'description': scrape_product_details(link),
    })

# Filter products within a price range
min_price = 10.00
max_price = 200.00
filtered_products = list(filter(lambda x: min_price <= x['price_eur'] <= max_price, product_data))
total_price_eur = reduce(lambda acc, x: acc + x['price_eur'], filtered_products, 0.0)

results = {
    'timestamp': datetime.now(timezone.utc).isoformat() + 'Z',
    'filtered_products': filtered_products,
    'total_price_eur': total_price_eur,
}

# Custom Serialization
def serialize(data):
    if isinstance(data, dict):
        serialized_items = []
        for key, value in data.items():
            serialized_items.append(f"{serialize(key)}:{serialize(value)}")
        return f"D{{{' '.join(serialized_items)}}}"
    
    elif isinstance(data, list):
        serialized_items = [serialize(item) for item in data]
        return f"L[{' '.join(serialized_items)}]"
    
    elif isinstance(data, str):
        return f"str({data})"
    
    elif isinstance(data, int):
        return f"int({data})"
    
    elif isinstance(data, float):
        return f"float({data})"
    
    else:
        raise ValueError(f"Unsupported data type: {type(data)}")

def deserialize(serialized_str):
    def parse_value(value_str):
        if value_str.startswith("str(") and value_str.endswith(")"):
            return value_str[4:-1]
        
        elif value_str.startswith("int(") and value_str.endswith(")"):
            return int(value_str[4:-1])
        
        elif value_str.startswith("float(") and value_str.endswith(")"):
            return float(value_str[6:-1])
        
        elif value_str.startswith("D{"):
            items = value_str[2:-1].split(' ')
            result_dict = {}
            for item in items:
                if item:
                    key_value = item.split(':', 1)
                    if len(key_value) == 2:
                        key = parse_value(key_value[0].strip())
                        value = parse_value(key_value[1].strip())
                        if isinstance(key, str):  # Ensure the key is a valid type
                            result_dict[key] = value
            return result_dict
        
        elif value_str.startswith("L["):
            items = value_str[2:-1].split(' ')
            result_list = [parse_value(item.strip()) for item in items if item]
            return result_list

    return parse_value(serialized_str)

# Serialize results
serialized_results = serialize(results)

# Deserialize the results
deserialized_results = deserialize(serialized_results)

# Print outputs
print("Serialized Results:")
print(serialized_results)
print("\nDeserialized Results:")
print(deserialized_results)
